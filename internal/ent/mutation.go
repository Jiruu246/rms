// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Jiruu246/rms/internal/ent/category"
	"github.com/Jiruu246/rms/internal/ent/menuitem"
	"github.com/Jiruu246/rms/internal/ent/modifier"
	"github.com/Jiruu246/rms/internal/ent/modifieroption"
	"github.com/Jiruu246/rms/internal/ent/predicate"
	"github.com/Jiruu246/rms/internal/ent/restaurant"
	"github.com/Jiruu246/rms/internal/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory       = "Category"
	TypeMenuItem       = "MenuItem"
	TypeModifier       = "Modifier"
	TypeModifierOption = "ModifierOption"
	TypeRestaurant     = "Restaurant"
	TypeUser           = "User"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	update_time       *time.Time
	name              *string
	description       *string
	display_order     *int
	adddisplay_order  *int
	is_active         *bool
	clearedFields     map[string]struct{}
	restaurant        *uuid.UUID
	clearedrestaurant bool
	menu_items        map[int64]struct{}
	removedmenu_items map[int64]struct{}
	clearedmenu_items bool
	done              bool
	oldValue          func(context.Context) (*Category, error)
	predicates        []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uuid.UUID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *CategoryMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *CategoryMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *CategoryMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *CategoryMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *CategoryMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetIsActive sets the "is_active" field.
func (m *CategoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CategoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CategoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetRestaurantID sets the "restaurant_id" field.
func (m *CategoryMutation) SetRestaurantID(u uuid.UUID) {
	m.restaurant = &u
}

// RestaurantID returns the value of the "restaurant_id" field in the mutation.
func (m *CategoryMutation) RestaurantID() (r uuid.UUID, exists bool) {
	v := m.restaurant
	if v == nil {
		return
	}
	return *v, true
}

// OldRestaurantID returns the old "restaurant_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldRestaurantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestaurantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestaurantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestaurantID: %w", err)
	}
	return oldValue.RestaurantID, nil
}

// ResetRestaurantID resets all changes to the "restaurant_id" field.
func (m *CategoryMutation) ResetRestaurantID() {
	m.restaurant = nil
}

// ClearRestaurant clears the "restaurant" edge to the Restaurant entity.
func (m *CategoryMutation) ClearRestaurant() {
	m.clearedrestaurant = true
	m.clearedFields[category.FieldRestaurantID] = struct{}{}
}

// RestaurantCleared reports if the "restaurant" edge to the Restaurant entity was cleared.
func (m *CategoryMutation) RestaurantCleared() bool {
	return m.clearedrestaurant
}

// RestaurantIDs returns the "restaurant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RestaurantID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) RestaurantIDs() (ids []uuid.UUID) {
	if id := m.restaurant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRestaurant resets all changes to the "restaurant" edge.
func (m *CategoryMutation) ResetRestaurant() {
	m.restaurant = nil
	m.clearedrestaurant = false
}

// AddMenuItemIDs adds the "menu_items" edge to the MenuItem entity by ids.
func (m *CategoryMutation) AddMenuItemIDs(ids ...int64) {
	if m.menu_items == nil {
		m.menu_items = make(map[int64]struct{})
	}
	for i := range ids {
		m.menu_items[ids[i]] = struct{}{}
	}
}

// ClearMenuItems clears the "menu_items" edge to the MenuItem entity.
func (m *CategoryMutation) ClearMenuItems() {
	m.clearedmenu_items = true
}

// MenuItemsCleared reports if the "menu_items" edge to the MenuItem entity was cleared.
func (m *CategoryMutation) MenuItemsCleared() bool {
	return m.clearedmenu_items
}

// RemoveMenuItemIDs removes the "menu_items" edge to the MenuItem entity by IDs.
func (m *CategoryMutation) RemoveMenuItemIDs(ids ...int64) {
	if m.removedmenu_items == nil {
		m.removedmenu_items = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menu_items, ids[i])
		m.removedmenu_items[ids[i]] = struct{}{}
	}
}

// RemovedMenuItems returns the removed IDs of the "menu_items" edge to the MenuItem entity.
func (m *CategoryMutation) RemovedMenuItemsIDs() (ids []int64) {
	for id := range m.removedmenu_items {
		ids = append(ids, id)
	}
	return
}

// MenuItemsIDs returns the "menu_items" edge IDs in the mutation.
func (m *CategoryMutation) MenuItemsIDs() (ids []int64) {
	for id := range m.menu_items {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItems resets all changes to the "menu_items" edge.
func (m *CategoryMutation) ResetMenuItems() {
	m.menu_items = nil
	m.clearedmenu_items = false
	m.removedmenu_items = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.display_order != nil {
		fields = append(fields, category.FieldDisplayOrder)
	}
	if m.is_active != nil {
		fields = append(fields, category.FieldIsActive)
	}
	if m.restaurant != nil {
		fields = append(fields, category.FieldRestaurantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldDisplayOrder:
		return m.DisplayOrder()
	case category.FieldIsActive:
		return m.IsActive()
	case category.FieldRestaurantID:
		return m.RestaurantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case category.FieldIsActive:
		return m.OldIsActive(ctx)
	case category.FieldRestaurantID:
		return m.OldRestaurantID(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case category.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case category.FieldRestaurantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestaurantID(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, category.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case category.FieldIsActive:
		m.ResetIsActive()
		return nil
	case category.FieldRestaurantID:
		m.ResetRestaurantID()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.restaurant != nil {
		edges = append(edges, category.EdgeRestaurant)
	}
	if m.menu_items != nil {
		edges = append(edges, category.EdgeMenuItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeRestaurant:
		if id := m.restaurant; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.menu_items))
		for id := range m.menu_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenu_items != nil {
		edges = append(edges, category.EdgeMenuItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.removedmenu_items))
		for id := range m.removedmenu_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrestaurant {
		edges = append(edges, category.EdgeRestaurant)
	}
	if m.clearedmenu_items {
		edges = append(edges, category.EdgeMenuItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeRestaurant:
		return m.clearedrestaurant
	case category.EdgeMenuItems:
		return m.clearedmenu_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeRestaurant:
		m.ClearRestaurant()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeRestaurant:
		m.ResetRestaurant()
		return nil
	case category.EdgeMenuItems:
		m.ResetMenuItems()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// MenuItemMutation represents an operation that mutates the MenuItem nodes in the graph.
type MenuItemMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	update_time       *time.Time
	name              *string
	description       *string
	price             *float64
	addprice          *float64
	image_url         *string
	is_available      *bool
	clearedFields     map[string]struct{}
	restaurant        *uuid.UUID
	clearedrestaurant bool
	category          *uuid.UUID
	clearedcategory   bool
	done              bool
	oldValue          func(context.Context) (*MenuItem, error)
	predicates        []predicate.MenuItem
}

var _ ent.Mutation = (*MenuItemMutation)(nil)

// menuitemOption allows management of the mutation configuration using functional options.
type menuitemOption func(*MenuItemMutation)

// newMenuItemMutation creates new mutation for the MenuItem entity.
func newMenuItemMutation(c config, op Op, opts ...menuitemOption) *MenuItemMutation {
	m := &MenuItemMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuItemID sets the ID field of the mutation.
func withMenuItemID(id int64) menuitemOption {
	return func(m *MenuItemMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuItem
		)
		m.oldValue = func(ctx context.Context) (*MenuItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuItem sets the old MenuItem of the mutation.
func withMenuItem(node *MenuItem) menuitemOption {
	return func(m *MenuItemMutation) {
		m.oldValue = func(context.Context) (*MenuItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuItem entities.
func (m *MenuItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *MenuItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MenuItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MenuItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *MenuItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MenuItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MenuItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MenuItemMutation) ResetDescription() {
	m.description = nil
}

// SetPrice sets the "price" field.
func (m *MenuItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MenuItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MenuItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MenuItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *MenuItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetImageURL sets the "image_url" field.
func (m *MenuItemMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *MenuItemMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *MenuItemMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[menuitem.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *MenuItemMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *MenuItemMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, menuitem.FieldImageURL)
}

// SetIsAvailable sets the "is_available" field.
func (m *MenuItemMutation) SetIsAvailable(b bool) {
	m.is_available = &b
}

// IsAvailable returns the value of the "is_available" field in the mutation.
func (m *MenuItemMutation) IsAvailable() (r bool, exists bool) {
	v := m.is_available
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAvailable returns the old "is_available" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldIsAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAvailable: %w", err)
	}
	return oldValue.IsAvailable, nil
}

// ResetIsAvailable resets all changes to the "is_available" field.
func (m *MenuItemMutation) ResetIsAvailable() {
	m.is_available = nil
}

// SetRestaurantID sets the "restaurant_id" field.
func (m *MenuItemMutation) SetRestaurantID(u uuid.UUID) {
	m.restaurant = &u
}

// RestaurantID returns the value of the "restaurant_id" field in the mutation.
func (m *MenuItemMutation) RestaurantID() (r uuid.UUID, exists bool) {
	v := m.restaurant
	if v == nil {
		return
	}
	return *v, true
}

// OldRestaurantID returns the old "restaurant_id" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldRestaurantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestaurantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestaurantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestaurantID: %w", err)
	}
	return oldValue.RestaurantID, nil
}

// ResetRestaurantID resets all changes to the "restaurant_id" field.
func (m *MenuItemMutation) ResetRestaurantID() {
	m.restaurant = nil
}

// SetCategoryID sets the "category_id" field.
func (m *MenuItemMutation) SetCategoryID(u uuid.UUID) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *MenuItemMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *MenuItemMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[menuitem.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *MenuItemMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *MenuItemMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, menuitem.FieldCategoryID)
}

// ClearRestaurant clears the "restaurant" edge to the Restaurant entity.
func (m *MenuItemMutation) ClearRestaurant() {
	m.clearedrestaurant = true
	m.clearedFields[menuitem.FieldRestaurantID] = struct{}{}
}

// RestaurantCleared reports if the "restaurant" edge to the Restaurant entity was cleared.
func (m *MenuItemMutation) RestaurantCleared() bool {
	return m.clearedrestaurant
}

// RestaurantIDs returns the "restaurant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RestaurantID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) RestaurantIDs() (ids []uuid.UUID) {
	if id := m.restaurant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRestaurant resets all changes to the "restaurant" edge.
func (m *MenuItemMutation) ResetRestaurant() {
	m.restaurant = nil
	m.clearedrestaurant = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *MenuItemMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[menuitem.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *MenuItemMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *MenuItemMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the MenuItemMutation builder.
func (m *MenuItemMutation) Where(ps ...predicate.MenuItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuItem).
func (m *MenuItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.update_time != nil {
		fields = append(fields, menuitem.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, menuitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, menuitem.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	if m.image_url != nil {
		fields = append(fields, menuitem.FieldImageURL)
	}
	if m.is_available != nil {
		fields = append(fields, menuitem.FieldIsAvailable)
	}
	if m.restaurant != nil {
		fields = append(fields, menuitem.FieldRestaurantID)
	}
	if m.category != nil {
		fields = append(fields, menuitem.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldUpdateTime:
		return m.UpdateTime()
	case menuitem.FieldName:
		return m.Name()
	case menuitem.FieldDescription:
		return m.Description()
	case menuitem.FieldPrice:
		return m.Price()
	case menuitem.FieldImageURL:
		return m.ImageURL()
	case menuitem.FieldIsAvailable:
		return m.IsAvailable()
	case menuitem.FieldRestaurantID:
		return m.RestaurantID()
	case menuitem.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case menuitem.FieldName:
		return m.OldName(ctx)
	case menuitem.FieldDescription:
		return m.OldDescription(ctx)
	case menuitem.FieldPrice:
		return m.OldPrice(ctx)
	case menuitem.FieldImageURL:
		return m.OldImageURL(ctx)
	case menuitem.FieldIsAvailable:
		return m.OldIsAvailable(ctx)
	case menuitem.FieldRestaurantID:
		return m.OldRestaurantID(ctx)
	case menuitem.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown MenuItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case menuitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menuitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case menuitem.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case menuitem.FieldIsAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAvailable(v)
		return nil
	case menuitem.FieldRestaurantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestaurantID(v)
		return nil
	case menuitem.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuitem.FieldImageURL) {
		fields = append(fields, menuitem.FieldImageURL)
	}
	if m.FieldCleared(menuitem.FieldCategoryID) {
		fields = append(fields, menuitem.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuItemMutation) ClearField(name string) error {
	switch name {
	case menuitem.FieldImageURL:
		m.ClearImageURL()
		return nil
	case menuitem.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown MenuItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuItemMutation) ResetField(name string) error {
	switch name {
	case menuitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case menuitem.FieldName:
		m.ResetName()
		return nil
	case menuitem.FieldDescription:
		m.ResetDescription()
		return nil
	case menuitem.FieldPrice:
		m.ResetPrice()
		return nil
	case menuitem.FieldImageURL:
		m.ResetImageURL()
		return nil
	case menuitem.FieldIsAvailable:
		m.ResetIsAvailable()
		return nil
	case menuitem.FieldRestaurantID:
		m.ResetRestaurantID()
		return nil
	case menuitem.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.restaurant != nil {
		edges = append(edges, menuitem.EdgeRestaurant)
	}
	if m.category != nil {
		edges = append(edges, menuitem.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeRestaurant:
		if id := m.restaurant; id != nil {
			return []ent.Value{*id}
		}
	case menuitem.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrestaurant {
		edges = append(edges, menuitem.EdgeRestaurant)
	}
	if m.clearedcategory {
		edges = append(edges, menuitem.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuItemMutation) EdgeCleared(name string) bool {
	switch name {
	case menuitem.EdgeRestaurant:
		return m.clearedrestaurant
	case menuitem.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuItemMutation) ClearEdge(name string) error {
	switch name {
	case menuitem.EdgeRestaurant:
		m.ClearRestaurant()
		return nil
	case menuitem.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown MenuItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuItemMutation) ResetEdge(name string) error {
	switch name {
	case menuitem.EdgeRestaurant:
		m.ResetRestaurant()
		return nil
	case menuitem.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown MenuItem edge %s", name)
}

// ModifierMutation represents an operation that mutates the Modifier nodes in the graph.
type ModifierMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	update_time             *time.Time
	name                    *string
	required                *bool
	multi_select            *bool
	max                     *int
	addmax                  *int
	clearedFields           map[string]struct{}
	restaurant              *uuid.UUID
	clearedrestaurant       bool
	modifier_options        map[uuid.UUID]struct{}
	removedmodifier_options map[uuid.UUID]struct{}
	clearedmodifier_options bool
	done                    bool
	oldValue                func(context.Context) (*Modifier, error)
	predicates              []predicate.Modifier
}

var _ ent.Mutation = (*ModifierMutation)(nil)

// modifierOption allows management of the mutation configuration using functional options.
type modifierOption func(*ModifierMutation)

// newModifierMutation creates new mutation for the Modifier entity.
func newModifierMutation(c config, op Op, opts ...modifierOption) *ModifierMutation {
	m := &ModifierMutation{
		config:        c,
		op:            op,
		typ:           TypeModifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModifierID sets the ID field of the mutation.
func withModifierID(id uuid.UUID) modifierOption {
	return func(m *ModifierMutation) {
		var (
			err   error
			once  sync.Once
			value *Modifier
		)
		m.oldValue = func(ctx context.Context) (*Modifier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Modifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModifier sets the old Modifier of the mutation.
func withModifier(node *Modifier) modifierOption {
	return func(m *ModifierMutation) {
		m.oldValue = func(context.Context) (*Modifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Modifier entities.
func (m *ModifierMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModifierMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModifierMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Modifier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *ModifierMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ModifierMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ModifierMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *ModifierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModifierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModifierMutation) ResetName() {
	m.name = nil
}

// SetRequired sets the "required" field.
func (m *ModifierMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *ModifierMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *ModifierMutation) ResetRequired() {
	m.required = nil
}

// SetMultiSelect sets the "multi_select" field.
func (m *ModifierMutation) SetMultiSelect(b bool) {
	m.multi_select = &b
}

// MultiSelect returns the value of the "multi_select" field in the mutation.
func (m *ModifierMutation) MultiSelect() (r bool, exists bool) {
	v := m.multi_select
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiSelect returns the old "multi_select" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldMultiSelect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiSelect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiSelect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiSelect: %w", err)
	}
	return oldValue.MultiSelect, nil
}

// ResetMultiSelect resets all changes to the "multi_select" field.
func (m *ModifierMutation) ResetMultiSelect() {
	m.multi_select = nil
}

// SetMax sets the "max" field.
func (m *ModifierMutation) SetMax(i int) {
	m.max = &i
	m.addmax = nil
}

// Max returns the value of the "max" field in the mutation.
func (m *ModifierMutation) Max() (r int, exists bool) {
	v := m.max
	if v == nil {
		return
	}
	return *v, true
}

// OldMax returns the old "max" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldMax(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMax: %w", err)
	}
	return oldValue.Max, nil
}

// AddMax adds i to the "max" field.
func (m *ModifierMutation) AddMax(i int) {
	if m.addmax != nil {
		*m.addmax += i
	} else {
		m.addmax = &i
	}
}

// AddedMax returns the value that was added to the "max" field in this mutation.
func (m *ModifierMutation) AddedMax() (r int, exists bool) {
	v := m.addmax
	if v == nil {
		return
	}
	return *v, true
}

// ResetMax resets all changes to the "max" field.
func (m *ModifierMutation) ResetMax() {
	m.max = nil
	m.addmax = nil
}

// SetRestaurantID sets the "restaurant_id" field.
func (m *ModifierMutation) SetRestaurantID(u uuid.UUID) {
	m.restaurant = &u
}

// RestaurantID returns the value of the "restaurant_id" field in the mutation.
func (m *ModifierMutation) RestaurantID() (r uuid.UUID, exists bool) {
	v := m.restaurant
	if v == nil {
		return
	}
	return *v, true
}

// OldRestaurantID returns the old "restaurant_id" field's value of the Modifier entity.
// If the Modifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierMutation) OldRestaurantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestaurantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestaurantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestaurantID: %w", err)
	}
	return oldValue.RestaurantID, nil
}

// ResetRestaurantID resets all changes to the "restaurant_id" field.
func (m *ModifierMutation) ResetRestaurantID() {
	m.restaurant = nil
}

// ClearRestaurant clears the "restaurant" edge to the Restaurant entity.
func (m *ModifierMutation) ClearRestaurant() {
	m.clearedrestaurant = true
	m.clearedFields[modifier.FieldRestaurantID] = struct{}{}
}

// RestaurantCleared reports if the "restaurant" edge to the Restaurant entity was cleared.
func (m *ModifierMutation) RestaurantCleared() bool {
	return m.clearedrestaurant
}

// RestaurantIDs returns the "restaurant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RestaurantID instead. It exists only for internal usage by the builders.
func (m *ModifierMutation) RestaurantIDs() (ids []uuid.UUID) {
	if id := m.restaurant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRestaurant resets all changes to the "restaurant" edge.
func (m *ModifierMutation) ResetRestaurant() {
	m.restaurant = nil
	m.clearedrestaurant = false
}

// AddModifierOptionIDs adds the "modifier_options" edge to the ModifierOption entity by ids.
func (m *ModifierMutation) AddModifierOptionIDs(ids ...uuid.UUID) {
	if m.modifier_options == nil {
		m.modifier_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modifier_options[ids[i]] = struct{}{}
	}
}

// ClearModifierOptions clears the "modifier_options" edge to the ModifierOption entity.
func (m *ModifierMutation) ClearModifierOptions() {
	m.clearedmodifier_options = true
}

// ModifierOptionsCleared reports if the "modifier_options" edge to the ModifierOption entity was cleared.
func (m *ModifierMutation) ModifierOptionsCleared() bool {
	return m.clearedmodifier_options
}

// RemoveModifierOptionIDs removes the "modifier_options" edge to the ModifierOption entity by IDs.
func (m *ModifierMutation) RemoveModifierOptionIDs(ids ...uuid.UUID) {
	if m.removedmodifier_options == nil {
		m.removedmodifier_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modifier_options, ids[i])
		m.removedmodifier_options[ids[i]] = struct{}{}
	}
}

// RemovedModifierOptions returns the removed IDs of the "modifier_options" edge to the ModifierOption entity.
func (m *ModifierMutation) RemovedModifierOptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedmodifier_options {
		ids = append(ids, id)
	}
	return
}

// ModifierOptionsIDs returns the "modifier_options" edge IDs in the mutation.
func (m *ModifierMutation) ModifierOptionsIDs() (ids []uuid.UUID) {
	for id := range m.modifier_options {
		ids = append(ids, id)
	}
	return
}

// ResetModifierOptions resets all changes to the "modifier_options" edge.
func (m *ModifierMutation) ResetModifierOptions() {
	m.modifier_options = nil
	m.clearedmodifier_options = false
	m.removedmodifier_options = nil
}

// Where appends a list predicates to the ModifierMutation builder.
func (m *ModifierMutation) Where(ps ...predicate.Modifier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModifierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModifierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Modifier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModifierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModifierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Modifier).
func (m *ModifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModifierMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.update_time != nil {
		fields = append(fields, modifier.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, modifier.FieldName)
	}
	if m.required != nil {
		fields = append(fields, modifier.FieldRequired)
	}
	if m.multi_select != nil {
		fields = append(fields, modifier.FieldMultiSelect)
	}
	if m.max != nil {
		fields = append(fields, modifier.FieldMax)
	}
	if m.restaurant != nil {
		fields = append(fields, modifier.FieldRestaurantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modifier.FieldUpdateTime:
		return m.UpdateTime()
	case modifier.FieldName:
		return m.Name()
	case modifier.FieldRequired:
		return m.Required()
	case modifier.FieldMultiSelect:
		return m.MultiSelect()
	case modifier.FieldMax:
		return m.Max()
	case modifier.FieldRestaurantID:
		return m.RestaurantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case modifier.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case modifier.FieldName:
		return m.OldName(ctx)
	case modifier.FieldRequired:
		return m.OldRequired(ctx)
	case modifier.FieldMultiSelect:
		return m.OldMultiSelect(ctx)
	case modifier.FieldMax:
		return m.OldMax(ctx)
	case modifier.FieldRestaurantID:
		return m.OldRestaurantID(ctx)
	}
	return nil, fmt.Errorf("unknown Modifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modifier.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case modifier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case modifier.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case modifier.FieldMultiSelect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiSelect(v)
		return nil
	case modifier.FieldMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMax(v)
		return nil
	case modifier.FieldRestaurantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestaurantID(v)
		return nil
	}
	return fmt.Errorf("unknown Modifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModifierMutation) AddedFields() []string {
	var fields []string
	if m.addmax != nil {
		fields = append(fields, modifier.FieldMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModifierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case modifier.FieldMax:
		return m.AddedMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case modifier.FieldMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMax(v)
		return nil
	}
	return fmt.Errorf("unknown Modifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModifierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModifierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Modifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModifierMutation) ResetField(name string) error {
	switch name {
	case modifier.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case modifier.FieldName:
		m.ResetName()
		return nil
	case modifier.FieldRequired:
		m.ResetRequired()
		return nil
	case modifier.FieldMultiSelect:
		m.ResetMultiSelect()
		return nil
	case modifier.FieldMax:
		m.ResetMax()
		return nil
	case modifier.FieldRestaurantID:
		m.ResetRestaurantID()
		return nil
	}
	return fmt.Errorf("unknown Modifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.restaurant != nil {
		edges = append(edges, modifier.EdgeRestaurant)
	}
	if m.modifier_options != nil {
		edges = append(edges, modifier.EdgeModifierOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modifier.EdgeRestaurant:
		if id := m.restaurant; id != nil {
			return []ent.Value{*id}
		}
	case modifier.EdgeModifierOptions:
		ids := make([]ent.Value, 0, len(m.modifier_options))
		for id := range m.modifier_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmodifier_options != nil {
		edges = append(edges, modifier.EdgeModifierOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModifierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case modifier.EdgeModifierOptions:
		ids := make([]ent.Value, 0, len(m.removedmodifier_options))
		for id := range m.removedmodifier_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrestaurant {
		edges = append(edges, modifier.EdgeRestaurant)
	}
	if m.clearedmodifier_options {
		edges = append(edges, modifier.EdgeModifierOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModifierMutation) EdgeCleared(name string) bool {
	switch name {
	case modifier.EdgeRestaurant:
		return m.clearedrestaurant
	case modifier.EdgeModifierOptions:
		return m.clearedmodifier_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModifierMutation) ClearEdge(name string) error {
	switch name {
	case modifier.EdgeRestaurant:
		m.ClearRestaurant()
		return nil
	}
	return fmt.Errorf("unknown Modifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModifierMutation) ResetEdge(name string) error {
	switch name {
	case modifier.EdgeRestaurant:
		m.ResetRestaurant()
		return nil
	case modifier.EdgeModifierOptions:
		m.ResetModifierOptions()
		return nil
	}
	return fmt.Errorf("unknown Modifier edge %s", name)
}

// ModifierOptionMutation represents an operation that mutates the ModifierOption nodes in the graph.
type ModifierOptionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	update_time     *time.Time
	name            *string
	price           *float64
	addprice        *float64
	image_url       *string
	available       *bool
	pre_select      *bool
	clearedFields   map[string]struct{}
	modifier        *uuid.UUID
	clearedmodifier bool
	done            bool
	oldValue        func(context.Context) (*ModifierOption, error)
	predicates      []predicate.ModifierOption
}

var _ ent.Mutation = (*ModifierOptionMutation)(nil)

// modifieroptionOption allows management of the mutation configuration using functional options.
type modifieroptionOption func(*ModifierOptionMutation)

// newModifierOptionMutation creates new mutation for the ModifierOption entity.
func newModifierOptionMutation(c config, op Op, opts ...modifieroptionOption) *ModifierOptionMutation {
	m := &ModifierOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeModifierOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModifierOptionID sets the ID field of the mutation.
func withModifierOptionID(id uuid.UUID) modifieroptionOption {
	return func(m *ModifierOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *ModifierOption
		)
		m.oldValue = func(ctx context.Context) (*ModifierOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModifierOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModifierOption sets the old ModifierOption of the mutation.
func withModifierOption(node *ModifierOption) modifieroptionOption {
	return func(m *ModifierOptionMutation) {
		m.oldValue = func(context.Context) (*ModifierOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModifierOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModifierOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModifierOption entities.
func (m *ModifierOptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModifierOptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModifierOptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModifierOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *ModifierOptionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ModifierOptionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ModifierOptionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *ModifierOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModifierOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModifierOptionMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *ModifierOptionMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ModifierOptionMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ModifierOptionMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ModifierOptionMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ModifierOptionMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetImageURL sets the "image_url" field.
func (m *ModifierOptionMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ModifierOptionMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *ModifierOptionMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[modifieroption.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *ModifierOptionMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[modifieroption.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ModifierOptionMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, modifieroption.FieldImageURL)
}

// SetAvailable sets the "available" field.
func (m *ModifierOptionMutation) SetAvailable(b bool) {
	m.available = &b
}

// Available returns the value of the "available" field in the mutation.
func (m *ModifierOptionMutation) Available() (r bool, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// ResetAvailable resets all changes to the "available" field.
func (m *ModifierOptionMutation) ResetAvailable() {
	m.available = nil
}

// SetPreSelect sets the "pre_select" field.
func (m *ModifierOptionMutation) SetPreSelect(b bool) {
	m.pre_select = &b
}

// PreSelect returns the value of the "pre_select" field in the mutation.
func (m *ModifierOptionMutation) PreSelect() (r bool, exists bool) {
	v := m.pre_select
	if v == nil {
		return
	}
	return *v, true
}

// OldPreSelect returns the old "pre_select" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldPreSelect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreSelect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreSelect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreSelect: %w", err)
	}
	return oldValue.PreSelect, nil
}

// ResetPreSelect resets all changes to the "pre_select" field.
func (m *ModifierOptionMutation) ResetPreSelect() {
	m.pre_select = nil
}

// SetModifierID sets the "modifier_id" field.
func (m *ModifierOptionMutation) SetModifierID(u uuid.UUID) {
	m.modifier = &u
}

// ModifierID returns the value of the "modifier_id" field in the mutation.
func (m *ModifierOptionMutation) ModifierID() (r uuid.UUID, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifierID returns the old "modifier_id" field's value of the ModifierOption entity.
// If the ModifierOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModifierOptionMutation) OldModifierID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifierID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifierID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifierID: %w", err)
	}
	return oldValue.ModifierID, nil
}

// ResetModifierID resets all changes to the "modifier_id" field.
func (m *ModifierOptionMutation) ResetModifierID() {
	m.modifier = nil
}

// ClearModifier clears the "modifier" edge to the Modifier entity.
func (m *ModifierOptionMutation) ClearModifier() {
	m.clearedmodifier = true
	m.clearedFields[modifieroption.FieldModifierID] = struct{}{}
}

// ModifierCleared reports if the "modifier" edge to the Modifier entity was cleared.
func (m *ModifierOptionMutation) ModifierCleared() bool {
	return m.clearedmodifier
}

// ModifierIDs returns the "modifier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModifierID instead. It exists only for internal usage by the builders.
func (m *ModifierOptionMutation) ModifierIDs() (ids []uuid.UUID) {
	if id := m.modifier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModifier resets all changes to the "modifier" edge.
func (m *ModifierOptionMutation) ResetModifier() {
	m.modifier = nil
	m.clearedmodifier = false
}

// Where appends a list predicates to the ModifierOptionMutation builder.
func (m *ModifierOptionMutation) Where(ps ...predicate.ModifierOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModifierOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModifierOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModifierOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModifierOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModifierOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModifierOption).
func (m *ModifierOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModifierOptionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.update_time != nil {
		fields = append(fields, modifieroption.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, modifieroption.FieldName)
	}
	if m.price != nil {
		fields = append(fields, modifieroption.FieldPrice)
	}
	if m.image_url != nil {
		fields = append(fields, modifieroption.FieldImageURL)
	}
	if m.available != nil {
		fields = append(fields, modifieroption.FieldAvailable)
	}
	if m.pre_select != nil {
		fields = append(fields, modifieroption.FieldPreSelect)
	}
	if m.modifier != nil {
		fields = append(fields, modifieroption.FieldModifierID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModifierOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modifieroption.FieldUpdateTime:
		return m.UpdateTime()
	case modifieroption.FieldName:
		return m.Name()
	case modifieroption.FieldPrice:
		return m.Price()
	case modifieroption.FieldImageURL:
		return m.ImageURL()
	case modifieroption.FieldAvailable:
		return m.Available()
	case modifieroption.FieldPreSelect:
		return m.PreSelect()
	case modifieroption.FieldModifierID:
		return m.ModifierID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModifierOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case modifieroption.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case modifieroption.FieldName:
		return m.OldName(ctx)
	case modifieroption.FieldPrice:
		return m.OldPrice(ctx)
	case modifieroption.FieldImageURL:
		return m.OldImageURL(ctx)
	case modifieroption.FieldAvailable:
		return m.OldAvailable(ctx)
	case modifieroption.FieldPreSelect:
		return m.OldPreSelect(ctx)
	case modifieroption.FieldModifierID:
		return m.OldModifierID(ctx)
	}
	return nil, fmt.Errorf("unknown ModifierOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModifierOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modifieroption.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case modifieroption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case modifieroption.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case modifieroption.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case modifieroption.FieldAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	case modifieroption.FieldPreSelect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreSelect(v)
		return nil
	case modifieroption.FieldModifierID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifierID(v)
		return nil
	}
	return fmt.Errorf("unknown ModifierOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModifierOptionMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, modifieroption.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModifierOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case modifieroption.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModifierOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case modifieroption.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ModifierOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModifierOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(modifieroption.FieldImageURL) {
		fields = append(fields, modifieroption.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModifierOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModifierOptionMutation) ClearField(name string) error {
	switch name {
	case modifieroption.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown ModifierOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModifierOptionMutation) ResetField(name string) error {
	switch name {
	case modifieroption.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case modifieroption.FieldName:
		m.ResetName()
		return nil
	case modifieroption.FieldPrice:
		m.ResetPrice()
		return nil
	case modifieroption.FieldImageURL:
		m.ResetImageURL()
		return nil
	case modifieroption.FieldAvailable:
		m.ResetAvailable()
		return nil
	case modifieroption.FieldPreSelect:
		m.ResetPreSelect()
		return nil
	case modifieroption.FieldModifierID:
		m.ResetModifierID()
		return nil
	}
	return fmt.Errorf("unknown ModifierOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModifierOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.modifier != nil {
		edges = append(edges, modifieroption.EdgeModifier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModifierOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modifieroption.EdgeModifier:
		if id := m.modifier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModifierOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModifierOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModifierOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmodifier {
		edges = append(edges, modifieroption.EdgeModifier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModifierOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case modifieroption.EdgeModifier:
		return m.clearedmodifier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModifierOptionMutation) ClearEdge(name string) error {
	switch name {
	case modifieroption.EdgeModifier:
		m.ClearModifier()
		return nil
	}
	return fmt.Errorf("unknown ModifierOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModifierOptionMutation) ResetEdge(name string) error {
	switch name {
	case modifieroption.EdgeModifier:
		m.ResetModifier()
		return nil
	}
	return fmt.Errorf("unknown ModifierOption edge %s", name)
}

// RestaurantMutation represents an operation that mutates the Restaurant nodes in the graph.
type RestaurantMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	update_time       *time.Time
	name              *string
	description       *string
	phone             *string
	email             *string
	address           *string
	city              *string
	state             *string
	zip_code          *string
	country           *string
	logo_url          *string
	cover_image_url   *string
	status            *restaurant.Status
	operating_hours   *map[string]interface{}
	currency          *string
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	menu_items        map[int64]struct{}
	removedmenu_items map[int64]struct{}
	clearedmenu_items bool
	categories        map[uuid.UUID]struct{}
	removedcategories map[uuid.UUID]struct{}
	clearedcategories bool
	modifiers         map[uuid.UUID]struct{}
	removedmodifiers  map[uuid.UUID]struct{}
	clearedmodifiers  bool
	done              bool
	oldValue          func(context.Context) (*Restaurant, error)
	predicates        []predicate.Restaurant
}

var _ ent.Mutation = (*RestaurantMutation)(nil)

// restaurantOption allows management of the mutation configuration using functional options.
type restaurantOption func(*RestaurantMutation)

// newRestaurantMutation creates new mutation for the Restaurant entity.
func newRestaurantMutation(c config, op Op, opts ...restaurantOption) *RestaurantMutation {
	m := &RestaurantMutation{
		config:        c,
		op:            op,
		typ:           TypeRestaurant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRestaurantID sets the ID field of the mutation.
func withRestaurantID(id uuid.UUID) restaurantOption {
	return func(m *RestaurantMutation) {
		var (
			err   error
			once  sync.Once
			value *Restaurant
		)
		m.oldValue = func(ctx context.Context) (*Restaurant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Restaurant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRestaurant sets the old Restaurant of the mutation.
func withRestaurant(node *Restaurant) restaurantOption {
	return func(m *RestaurantMutation) {
		m.oldValue = func(context.Context) (*Restaurant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RestaurantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RestaurantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Restaurant entities.
func (m *RestaurantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RestaurantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RestaurantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Restaurant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *RestaurantMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RestaurantMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RestaurantMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *RestaurantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RestaurantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RestaurantMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RestaurantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RestaurantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RestaurantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[restaurant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RestaurantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[restaurant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RestaurantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, restaurant.FieldDescription)
}

// SetPhone sets the "phone" field.
func (m *RestaurantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RestaurantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RestaurantMutation) ResetPhone() {
	m.phone = nil
}

// SetEmail sets the "email" field.
func (m *RestaurantMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *RestaurantMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *RestaurantMutation) ResetEmail() {
	m.email = nil
}

// SetAddress sets the "address" field.
func (m *RestaurantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *RestaurantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *RestaurantMutation) ResetAddress() {
	m.address = nil
}

// SetCity sets the "city" field.
func (m *RestaurantMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *RestaurantMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *RestaurantMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *RestaurantMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *RestaurantMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RestaurantMutation) ResetState() {
	m.state = nil
}

// SetZipCode sets the "zip_code" field.
func (m *RestaurantMutation) SetZipCode(s string) {
	m.zip_code = &s
}

// ZipCode returns the value of the "zip_code" field in the mutation.
func (m *RestaurantMutation) ZipCode() (r string, exists bool) {
	v := m.zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zip_code" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ResetZipCode resets all changes to the "zip_code" field.
func (m *RestaurantMutation) ResetZipCode() {
	m.zip_code = nil
}

// SetCountry sets the "country" field.
func (m *RestaurantMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *RestaurantMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *RestaurantMutation) ResetCountry() {
	m.country = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *RestaurantMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *RestaurantMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *RestaurantMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[restaurant.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *RestaurantMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[restaurant.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *RestaurantMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, restaurant.FieldLogoURL)
}

// SetCoverImageURL sets the "cover_image_url" field.
func (m *RestaurantMutation) SetCoverImageURL(s string) {
	m.cover_image_url = &s
}

// CoverImageURL returns the value of the "cover_image_url" field in the mutation.
func (m *RestaurantMutation) CoverImageURL() (r string, exists bool) {
	v := m.cover_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageURL returns the old "cover_image_url" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldCoverImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageURL: %w", err)
	}
	return oldValue.CoverImageURL, nil
}

// ClearCoverImageURL clears the value of the "cover_image_url" field.
func (m *RestaurantMutation) ClearCoverImageURL() {
	m.cover_image_url = nil
	m.clearedFields[restaurant.FieldCoverImageURL] = struct{}{}
}

// CoverImageURLCleared returns if the "cover_image_url" field was cleared in this mutation.
func (m *RestaurantMutation) CoverImageURLCleared() bool {
	_, ok := m.clearedFields[restaurant.FieldCoverImageURL]
	return ok
}

// ResetCoverImageURL resets all changes to the "cover_image_url" field.
func (m *RestaurantMutation) ResetCoverImageURL() {
	m.cover_image_url = nil
	delete(m.clearedFields, restaurant.FieldCoverImageURL)
}

// SetStatus sets the "status" field.
func (m *RestaurantMutation) SetStatus(r restaurant.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RestaurantMutation) Status() (r restaurant.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldStatus(ctx context.Context) (v restaurant.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RestaurantMutation) ResetStatus() {
	m.status = nil
}

// SetOperatingHours sets the "operating_hours" field.
func (m *RestaurantMutation) SetOperatingHours(value map[string]interface{}) {
	m.operating_hours = &value
}

// OperatingHours returns the value of the "operating_hours" field in the mutation.
func (m *RestaurantMutation) OperatingHours() (r map[string]interface{}, exists bool) {
	v := m.operating_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatingHours returns the old "operating_hours" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldOperatingHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatingHours: %w", err)
	}
	return oldValue.OperatingHours, nil
}

// ClearOperatingHours clears the value of the "operating_hours" field.
func (m *RestaurantMutation) ClearOperatingHours() {
	m.operating_hours = nil
	m.clearedFields[restaurant.FieldOperatingHours] = struct{}{}
}

// OperatingHoursCleared returns if the "operating_hours" field was cleared in this mutation.
func (m *RestaurantMutation) OperatingHoursCleared() bool {
	_, ok := m.clearedFields[restaurant.FieldOperatingHours]
	return ok
}

// ResetOperatingHours resets all changes to the "operating_hours" field.
func (m *RestaurantMutation) ResetOperatingHours() {
	m.operating_hours = nil
	delete(m.clearedFields, restaurant.FieldOperatingHours)
}

// SetCurrency sets the "currency" field.
func (m *RestaurantMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *RestaurantMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *RestaurantMutation) ResetCurrency() {
	m.currency = nil
}

// SetUserID sets the "user_id" field.
func (m *RestaurantMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RestaurantMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Restaurant entity.
// If the Restaurant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RestaurantMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RestaurantMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RestaurantMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[restaurant.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RestaurantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RestaurantMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RestaurantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMenuItemIDs adds the "menu_items" edge to the MenuItem entity by ids.
func (m *RestaurantMutation) AddMenuItemIDs(ids ...int64) {
	if m.menu_items == nil {
		m.menu_items = make(map[int64]struct{})
	}
	for i := range ids {
		m.menu_items[ids[i]] = struct{}{}
	}
}

// ClearMenuItems clears the "menu_items" edge to the MenuItem entity.
func (m *RestaurantMutation) ClearMenuItems() {
	m.clearedmenu_items = true
}

// MenuItemsCleared reports if the "menu_items" edge to the MenuItem entity was cleared.
func (m *RestaurantMutation) MenuItemsCleared() bool {
	return m.clearedmenu_items
}

// RemoveMenuItemIDs removes the "menu_items" edge to the MenuItem entity by IDs.
func (m *RestaurantMutation) RemoveMenuItemIDs(ids ...int64) {
	if m.removedmenu_items == nil {
		m.removedmenu_items = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menu_items, ids[i])
		m.removedmenu_items[ids[i]] = struct{}{}
	}
}

// RemovedMenuItems returns the removed IDs of the "menu_items" edge to the MenuItem entity.
func (m *RestaurantMutation) RemovedMenuItemsIDs() (ids []int64) {
	for id := range m.removedmenu_items {
		ids = append(ids, id)
	}
	return
}

// MenuItemsIDs returns the "menu_items" edge IDs in the mutation.
func (m *RestaurantMutation) MenuItemsIDs() (ids []int64) {
	for id := range m.menu_items {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItems resets all changes to the "menu_items" edge.
func (m *RestaurantMutation) ResetMenuItems() {
	m.menu_items = nil
	m.clearedmenu_items = false
	m.removedmenu_items = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *RestaurantMutation) AddCategoryIDs(ids ...uuid.UUID) {
	if m.categories == nil {
		m.categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *RestaurantMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *RestaurantMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *RestaurantMutation) RemoveCategoryIDs(ids ...uuid.UUID) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *RestaurantMutation) RemovedCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *RestaurantMutation) CategoriesIDs() (ids []uuid.UUID) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *RestaurantMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddModifierIDs adds the "modifiers" edge to the Modifier entity by ids.
func (m *RestaurantMutation) AddModifierIDs(ids ...uuid.UUID) {
	if m.modifiers == nil {
		m.modifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.modifiers[ids[i]] = struct{}{}
	}
}

// ClearModifiers clears the "modifiers" edge to the Modifier entity.
func (m *RestaurantMutation) ClearModifiers() {
	m.clearedmodifiers = true
}

// ModifiersCleared reports if the "modifiers" edge to the Modifier entity was cleared.
func (m *RestaurantMutation) ModifiersCleared() bool {
	return m.clearedmodifiers
}

// RemoveModifierIDs removes the "modifiers" edge to the Modifier entity by IDs.
func (m *RestaurantMutation) RemoveModifierIDs(ids ...uuid.UUID) {
	if m.removedmodifiers == nil {
		m.removedmodifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.modifiers, ids[i])
		m.removedmodifiers[ids[i]] = struct{}{}
	}
}

// RemovedModifiers returns the removed IDs of the "modifiers" edge to the Modifier entity.
func (m *RestaurantMutation) RemovedModifiersIDs() (ids []uuid.UUID) {
	for id := range m.removedmodifiers {
		ids = append(ids, id)
	}
	return
}

// ModifiersIDs returns the "modifiers" edge IDs in the mutation.
func (m *RestaurantMutation) ModifiersIDs() (ids []uuid.UUID) {
	for id := range m.modifiers {
		ids = append(ids, id)
	}
	return
}

// ResetModifiers resets all changes to the "modifiers" edge.
func (m *RestaurantMutation) ResetModifiers() {
	m.modifiers = nil
	m.clearedmodifiers = false
	m.removedmodifiers = nil
}

// Where appends a list predicates to the RestaurantMutation builder.
func (m *RestaurantMutation) Where(ps ...predicate.Restaurant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RestaurantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RestaurantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Restaurant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RestaurantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RestaurantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Restaurant).
func (m *RestaurantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RestaurantMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.update_time != nil {
		fields = append(fields, restaurant.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, restaurant.FieldName)
	}
	if m.description != nil {
		fields = append(fields, restaurant.FieldDescription)
	}
	if m.phone != nil {
		fields = append(fields, restaurant.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, restaurant.FieldEmail)
	}
	if m.address != nil {
		fields = append(fields, restaurant.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, restaurant.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, restaurant.FieldState)
	}
	if m.zip_code != nil {
		fields = append(fields, restaurant.FieldZipCode)
	}
	if m.country != nil {
		fields = append(fields, restaurant.FieldCountry)
	}
	if m.logo_url != nil {
		fields = append(fields, restaurant.FieldLogoURL)
	}
	if m.cover_image_url != nil {
		fields = append(fields, restaurant.FieldCoverImageURL)
	}
	if m.status != nil {
		fields = append(fields, restaurant.FieldStatus)
	}
	if m.operating_hours != nil {
		fields = append(fields, restaurant.FieldOperatingHours)
	}
	if m.currency != nil {
		fields = append(fields, restaurant.FieldCurrency)
	}
	if m.user != nil {
		fields = append(fields, restaurant.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RestaurantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case restaurant.FieldUpdateTime:
		return m.UpdateTime()
	case restaurant.FieldName:
		return m.Name()
	case restaurant.FieldDescription:
		return m.Description()
	case restaurant.FieldPhone:
		return m.Phone()
	case restaurant.FieldEmail:
		return m.Email()
	case restaurant.FieldAddress:
		return m.Address()
	case restaurant.FieldCity:
		return m.City()
	case restaurant.FieldState:
		return m.State()
	case restaurant.FieldZipCode:
		return m.ZipCode()
	case restaurant.FieldCountry:
		return m.Country()
	case restaurant.FieldLogoURL:
		return m.LogoURL()
	case restaurant.FieldCoverImageURL:
		return m.CoverImageURL()
	case restaurant.FieldStatus:
		return m.Status()
	case restaurant.FieldOperatingHours:
		return m.OperatingHours()
	case restaurant.FieldCurrency:
		return m.Currency()
	case restaurant.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RestaurantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case restaurant.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case restaurant.FieldName:
		return m.OldName(ctx)
	case restaurant.FieldDescription:
		return m.OldDescription(ctx)
	case restaurant.FieldPhone:
		return m.OldPhone(ctx)
	case restaurant.FieldEmail:
		return m.OldEmail(ctx)
	case restaurant.FieldAddress:
		return m.OldAddress(ctx)
	case restaurant.FieldCity:
		return m.OldCity(ctx)
	case restaurant.FieldState:
		return m.OldState(ctx)
	case restaurant.FieldZipCode:
		return m.OldZipCode(ctx)
	case restaurant.FieldCountry:
		return m.OldCountry(ctx)
	case restaurant.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case restaurant.FieldCoverImageURL:
		return m.OldCoverImageURL(ctx)
	case restaurant.FieldStatus:
		return m.OldStatus(ctx)
	case restaurant.FieldOperatingHours:
		return m.OldOperatingHours(ctx)
	case restaurant.FieldCurrency:
		return m.OldCurrency(ctx)
	case restaurant.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Restaurant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RestaurantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case restaurant.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case restaurant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case restaurant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case restaurant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case restaurant.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case restaurant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case restaurant.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case restaurant.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case restaurant.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case restaurant.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case restaurant.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case restaurant.FieldCoverImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageURL(v)
		return nil
	case restaurant.FieldStatus:
		v, ok := value.(restaurant.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case restaurant.FieldOperatingHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatingHours(v)
		return nil
	case restaurant.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case restaurant.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Restaurant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RestaurantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RestaurantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RestaurantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Restaurant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RestaurantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(restaurant.FieldDescription) {
		fields = append(fields, restaurant.FieldDescription)
	}
	if m.FieldCleared(restaurant.FieldLogoURL) {
		fields = append(fields, restaurant.FieldLogoURL)
	}
	if m.FieldCleared(restaurant.FieldCoverImageURL) {
		fields = append(fields, restaurant.FieldCoverImageURL)
	}
	if m.FieldCleared(restaurant.FieldOperatingHours) {
		fields = append(fields, restaurant.FieldOperatingHours)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RestaurantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RestaurantMutation) ClearField(name string) error {
	switch name {
	case restaurant.FieldDescription:
		m.ClearDescription()
		return nil
	case restaurant.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case restaurant.FieldCoverImageURL:
		m.ClearCoverImageURL()
		return nil
	case restaurant.FieldOperatingHours:
		m.ClearOperatingHours()
		return nil
	}
	return fmt.Errorf("unknown Restaurant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RestaurantMutation) ResetField(name string) error {
	switch name {
	case restaurant.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case restaurant.FieldName:
		m.ResetName()
		return nil
	case restaurant.FieldDescription:
		m.ResetDescription()
		return nil
	case restaurant.FieldPhone:
		m.ResetPhone()
		return nil
	case restaurant.FieldEmail:
		m.ResetEmail()
		return nil
	case restaurant.FieldAddress:
		m.ResetAddress()
		return nil
	case restaurant.FieldCity:
		m.ResetCity()
		return nil
	case restaurant.FieldState:
		m.ResetState()
		return nil
	case restaurant.FieldZipCode:
		m.ResetZipCode()
		return nil
	case restaurant.FieldCountry:
		m.ResetCountry()
		return nil
	case restaurant.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case restaurant.FieldCoverImageURL:
		m.ResetCoverImageURL()
		return nil
	case restaurant.FieldStatus:
		m.ResetStatus()
		return nil
	case restaurant.FieldOperatingHours:
		m.ResetOperatingHours()
		return nil
	case restaurant.FieldCurrency:
		m.ResetCurrency()
		return nil
	case restaurant.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Restaurant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RestaurantMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, restaurant.EdgeUser)
	}
	if m.menu_items != nil {
		edges = append(edges, restaurant.EdgeMenuItems)
	}
	if m.categories != nil {
		edges = append(edges, restaurant.EdgeCategories)
	}
	if m.modifiers != nil {
		edges = append(edges, restaurant.EdgeModifiers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RestaurantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case restaurant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case restaurant.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.menu_items))
		for id := range m.menu_items {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeModifiers:
		ids := make([]ent.Value, 0, len(m.modifiers))
		for id := range m.modifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RestaurantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmenu_items != nil {
		edges = append(edges, restaurant.EdgeMenuItems)
	}
	if m.removedcategories != nil {
		edges = append(edges, restaurant.EdgeCategories)
	}
	if m.removedmodifiers != nil {
		edges = append(edges, restaurant.EdgeModifiers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RestaurantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case restaurant.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.removedmenu_items))
		for id := range m.removedmenu_items {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case restaurant.EdgeModifiers:
		ids := make([]ent.Value, 0, len(m.removedmodifiers))
		for id := range m.removedmodifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RestaurantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, restaurant.EdgeUser)
	}
	if m.clearedmenu_items {
		edges = append(edges, restaurant.EdgeMenuItems)
	}
	if m.clearedcategories {
		edges = append(edges, restaurant.EdgeCategories)
	}
	if m.clearedmodifiers {
		edges = append(edges, restaurant.EdgeModifiers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RestaurantMutation) EdgeCleared(name string) bool {
	switch name {
	case restaurant.EdgeUser:
		return m.cleareduser
	case restaurant.EdgeMenuItems:
		return m.clearedmenu_items
	case restaurant.EdgeCategories:
		return m.clearedcategories
	case restaurant.EdgeModifiers:
		return m.clearedmodifiers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RestaurantMutation) ClearEdge(name string) error {
	switch name {
	case restaurant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Restaurant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RestaurantMutation) ResetEdge(name string) error {
	switch name {
	case restaurant.EdgeUser:
		m.ResetUser()
		return nil
	case restaurant.EdgeMenuItems:
		m.ResetMenuItems()
		return nil
	case restaurant.EdgeCategories:
		m.ResetCategories()
		return nil
	case restaurant.EdgeModifiers:
		m.ResetModifiers()
		return nil
	}
	return fmt.Errorf("unknown Restaurant edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	update_time        *time.Time
	name               *string
	email              *string
	phone_number       *string
	is_active          *bool
	password_hash      *string
	clearedFields      map[string]struct{}
	restaurants        map[uuid.UUID]struct{}
	removedrestaurants map[uuid.UUID]struct{}
	clearedrestaurants bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// AddRestaurantIDs adds the "restaurants" edge to the Restaurant entity by ids.
func (m *UserMutation) AddRestaurantIDs(ids ...uuid.UUID) {
	if m.restaurants == nil {
		m.restaurants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.restaurants[ids[i]] = struct{}{}
	}
}

// ClearRestaurants clears the "restaurants" edge to the Restaurant entity.
func (m *UserMutation) ClearRestaurants() {
	m.clearedrestaurants = true
}

// RestaurantsCleared reports if the "restaurants" edge to the Restaurant entity was cleared.
func (m *UserMutation) RestaurantsCleared() bool {
	return m.clearedrestaurants
}

// RemoveRestaurantIDs removes the "restaurants" edge to the Restaurant entity by IDs.
func (m *UserMutation) RemoveRestaurantIDs(ids ...uuid.UUID) {
	if m.removedrestaurants == nil {
		m.removedrestaurants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.restaurants, ids[i])
		m.removedrestaurants[ids[i]] = struct{}{}
	}
}

// RemovedRestaurants returns the removed IDs of the "restaurants" edge to the Restaurant entity.
func (m *UserMutation) RemovedRestaurantsIDs() (ids []uuid.UUID) {
	for id := range m.removedrestaurants {
		ids = append(ids, id)
	}
	return
}

// RestaurantsIDs returns the "restaurants" edge IDs in the mutation.
func (m *UserMutation) RestaurantsIDs() (ids []uuid.UUID) {
	for id := range m.restaurants {
		ids = append(ids, id)
	}
	return
}

// ResetRestaurants resets all changes to the "restaurants" edge.
func (m *UserMutation) ResetRestaurants() {
	m.restaurants = nil
	m.clearedrestaurants = false
	m.removedrestaurants = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.restaurants != nil {
		edges = append(edges, user.EdgeRestaurants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRestaurants:
		ids := make([]ent.Value, 0, len(m.restaurants))
		for id := range m.restaurants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrestaurants != nil {
		edges = append(edges, user.EdgeRestaurants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRestaurants:
		ids := make([]ent.Value, 0, len(m.removedrestaurants))
		for id := range m.removedrestaurants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrestaurants {
		edges = append(edges, user.EdgeRestaurants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRestaurants:
		return m.clearedrestaurants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRestaurants:
		m.ResetRestaurants()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
